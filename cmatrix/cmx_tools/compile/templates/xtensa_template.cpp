/*
 * Generated inference code for Xtensa target (ESP32)
 * Model: $model_name
 * Target: $target
 * Generated by cmx_tools
 */

$includes
#include <cmatrix.hpp>
#include <esp_system.h>
#include <esp_timer.h>
#include <esp_log.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <xtensa/hal.h>

$defines

// Memory alignment for Xtensa
#define ALIGN_XTENSA __attribute__((aligned(ALIGNMENT)))

// ESP32 specific configurations
#define ESP32_CPU_FREQ_HZ 240000000  // 240 MHz

// Logging tag
static const char* TAG = "${model_name}";

/*
 * Static tensor declarations
 * Optimized for ESP32 memory layout (IRAM/DRAM)
 */
$tensor_declarations

// Model weights and biases (stored in flash/SPIRAM)
static const float model_weights[] ALIGN_XTENSA = {
    // Weights will be populated during code generation
    0.0f
};

static const float model_biases[] ALIGN_XTENSA = {
    // Biases will be populated during code generation
    0.0f
};

// Working memory buffers (in DRAM)
static float input_buffer[1024] ALIGN_XTENSA;
static float output_buffer[1024] ALIGN_XTENSA;
static float temp_buffer[2048] ALIGN_XTENSA;

// Task handle for inference task
static TaskHandle_t inference_task_handle = NULL;

/*
 * ESP32 specific utility functions
 */
static inline int64_t esp32_get_time_us(void) {
    return esp_timer_get_time();
}

static void esp32_print_memory_info(void) {
    ESP_LOGI(TAG, "Free heap: %d bytes", esp_get_free_heap_size());
    ESP_LOGI(TAG, "Minimum free heap: %d bytes", esp_get_minimum_free_heap_size());
    
#ifdef CONFIG_SPIRAM_SUPPORT
    ESP_LOGI(TAG, "Free SPIRAM: %d bytes", heap_caps_get_free_size(MALLOC_CAP_SPIRAM));
#endif
}

/*
 * Layer implementation functions with Xtensa optimizations
 */
$layer_functions

/*
 * Optimized convolution using Xtensa DSP instructions
 */
void xtensa_conv2d_optimized(const float* input, float* output, 
                            const float* weights, const float* bias,
                            int in_channels, int out_channels, int kernel_size) {
    // Use Xtensa DSP extensions if available
#ifdef __XTENSA_WINDOWED_ABI__
    // Optimized implementation using Xtensa specific instructions
    // This would use xt_* intrinsics for DSP operations
    
    for (int oc = 0; oc < out_channels; oc++) {
        float acc = bias[oc];
        
        for (int ic = 0; ic < in_channels; ic++) {
            for (int k = 0; k < kernel_size * kernel_size; k++) {
                int weight_idx = oc * in_channels * kernel_size * kernel_size + 
                               ic * kernel_size * kernel_size + k;
                int input_idx = ic * kernel_size + k;
                
                acc += input[input_idx] * weights[weight_idx];
            }
        }
        
        output[oc] = acc;
    }
#else
    // Fallback to cmx_core implementation
    cmx_conv2d(input, output, weights, bias, in_channels, out_channels, kernel_size);
#endif
}

/*
 * Memory management for ESP32
 */
static void* esp32_aligned_malloc(size_t size, size_t alignment) {
    void* ptr = NULL;
    
#ifdef CONFIG_SPIRAM_SUPPORT
    // Try to allocate from SPIRAM first for large buffers
    if (size > 1024) {
        ptr = heap_caps_aligned_alloc(alignment, size, MALLOC_CAP_SPIRAM);
    }
#endif
    
    // Fallback to internal RAM
    if (ptr == NULL) {
        ptr = heap_caps_aligned_alloc(alignment, size, MALLOC_CAP_8BIT);
    }
    
    return ptr;
}

static void esp32_aligned_free(void* ptr) {
    if (ptr != NULL) {
        heap_caps_free(ptr);
    }
}

/*
 * Model initialization
 */
int ${model_name}_init(void) {
    ESP_LOGI(TAG, "Initializing model...");
    
    // Print memory info
    esp32_print_memory_info();
    
    // Initialize cmx_core library
    if (cmx_init() != CMX_SUCCESS) {
        ESP_LOGE(TAG, "Failed to initialize cmx_core");
        return -1;
    }
    
    // Clear buffers
    memset(input_buffer, 0, sizeof(input_buffer));
    memset(output_buffer, 0, sizeof(output_buffer));
    memset(temp_buffer, 0, sizeof(temp_buffer));
    
    ESP_LOGI(TAG, "Model initialized successfully");
    return 0;
}

/*
 * Model cleanup
 */
void ${model_name}_cleanup(void) {
    ESP_LOGI(TAG, "Cleaning up model...");
    cmx_shutdown();
    
    // Clean up any allocated resources
    if (inference_task_handle != NULL) {
        vTaskDelete(inference_task_handle);
        inference_task_handle = NULL;
    }
}

/*
 * Main inference function
 */
int ${model_name}_inference(const float* input, float* output) {
    // Validate inputs
    if (input == NULL || output == NULL) {
        ESP_LOGE(TAG, "Invalid input or output pointer");
        return -1;
    }
    
    ESP_LOGD(TAG, "Starting inference...");
    
    // Copy input to working buffer
    memcpy(input_buffer, input, ${model_name}_get_input_size() * sizeof(float));
    
    // Execute inference pipeline
$inference_loop
    
    // Copy result to output buffer
    memcpy(output, output_buffer, ${model_name}_get_output_size() * sizeof(float));
    
    ESP_LOGD(TAG, "Inference completed");
    return 0;
}

/*
 * Asynchronous inference task
 */
static void inference_task(void* pvParameters) {
    struct {
        const float* input;
        float* output;
        int* result;
        SemaphoreHandle_t* done_semaphore;
    } *params = (typeof(params))pvParameters;
    
    ESP_LOGI(TAG, "Inference task started");
    
    // Run inference
    *(params->result) = ${model_name}_inference(params->input, params->output);
    
    // Signal completion
    xSemaphoreGive(*(params->done_semaphore));
    
    // Task will be deleted by cleanup function
    vTaskSuspend(NULL);
}

/*
 * Asynchronous inference function
 */
int ${model_name}_inference_async(const float* input, float* output, 
                                 TickType_t timeout_ticks) {
    static SemaphoreHandle_t done_semaphore = NULL;
    static int result;
    
    // Create semaphore if not exists
    if (done_semaphore == NULL) {
        done_semaphore = xSemaphoreCreateBinary();
        if (done_semaphore == NULL) {
            ESP_LOGE(TAG, "Failed to create semaphore");
            return -1;
        }
    }
    
    // Prepare task parameters
    struct {
        const float* input;
        float* output;
        int* result;
        SemaphoreHandle_t* done_semaphore;
    } task_params = {
        .input = input,
        .output = output,
        .result = &result,
        .done_semaphore = &done_semaphore
    };
    
    // Create inference task
    BaseType_t task_result = xTaskCreate(
        inference_task,
        "inference_task",
        8192,  // Stack size
        &task_params,
        5,     // Priority
        &inference_task_handle
    );
    
    if (task_result != pdPASS) {
        ESP_LOGE(TAG, "Failed to create inference task");
        return -1;
    }
    
    // Wait for completion
    if (xSemaphoreTake(done_semaphore, timeout_ticks) == pdTRUE) {
        return result;
    } else {
        ESP_LOGE(TAG, "Inference timeout");
        vTaskDelete(inference_task_handle);
        inference_task_handle = NULL;
        return -2;
    }
}

/*
 * Model metadata functions
 */
const char* ${model_name}_get_version(void) {
    return "1.0.0-esp32";
}

int ${model_name}_get_input_size(void) {
    return 224 * 224 * 3; // Will be replaced with actual size
}

int ${model_name}_get_output_size(void) {
    return 1000; // Will be replaced with actual size
}

/*
 * Performance monitoring
 */
void ${model_name}_print_perf_info(void) {
    ESP_LOGI(TAG, "ESP32 Performance Information:");
    ESP_LOGI(TAG, "CPU Frequency: %d MHz", ESP32_CPU_FREQ_HZ / 1000000);
    ESP_LOGI(TAG, "Free heap: %d bytes", esp_get_free_heap_size());
    
#ifdef CONFIG_SPIRAM_SUPPORT
    ESP_LOGI(TAG, "SPIRAM support: Enabled");
    ESP_LOGI(TAG, "Free SPIRAM: %d bytes", heap_caps_get_free_size(MALLOC_CAP_SPIRAM));
#else
    ESP_LOGI(TAG, "SPIRAM support: Disabled");
#endif

#ifdef CONFIG_FREERTOS_UNICORE
    ESP_LOGI(TAG, "CPU cores: 1 (unicore)");
#else
    ESP_LOGI(TAG, "CPU cores: 2 (dual core)");
#endif
}

/*
 * Main application entry point
 */
extern "C" void app_main(void) {
    ESP_LOGI(TAG, "ESP32 Neural Network Inference");
    
    // Print system information
    ${model_name}_print_perf_info();
    
    // Initialize model
    if (${model_name}_init() != 0) {
        ESP_LOGE(TAG, "Failed to initialize model");
        return;
    }
    
    // Allocate input/output buffers
    float* input = (float*)esp32_aligned_malloc(
        ${model_name}_get_input_size() * sizeof(float), 16);
    float* output = (float*)esp32_aligned_malloc(
        ${model_name}_get_output_size() * sizeof(float), 16);
    
    if (input == NULL || output == NULL) {
        ESP_LOGE(TAG, "Failed to allocate memory for input/output");
        goto cleanup;
    }
    
    // Initialize with dummy data for testing
    for (int i = 0; i < ${model_name}_get_input_size(); i++) {
        input[i] = 0.1f * (i % 10);
    }
    
    // Run inference with timing
    ESP_LOGI(TAG, "Running inference...");
    int64_t start_time = esp32_get_time_us();
    
    int result = ${model_name}_inference(input, output);
    
    int64_t end_time = esp32_get_time_us();
    int64_t elapsed_us = end_time - start_time;
    
    if (result == 0) {
        ESP_LOGI(TAG, "Inference completed successfully");
        ESP_LOGI(TAG, "Execution time: %lld Î¼s (%.2f ms)", 
                elapsed_us, elapsed_us / 1000.0);
        
        // Print first few outputs
        ESP_LOGI(TAG, "Output (first 10 values):");
        for (int i = 0; i < 10 && i < ${model_name}_get_output_size(); i++) {
            printf("%.3f ", output[i]);
        }
        printf("\\n");
        
        // Test async inference
        ESP_LOGI(TAG, "Testing async inference...");
        result = ${model_name}_inference_async(input, output, pdMS_TO_TICKS(5000));
        if (result == 0) {
            ESP_LOGI(TAG, "Async inference completed successfully");
        } else {
            ESP_LOGE(TAG, "Async inference failed: %d", result);
        }
        
    } else {
        ESP_LOGE(TAG, "Inference failed with error code: %d", result);
    }
    
cleanup:
    // Cleanup
    esp32_aligned_free(input);
    esp32_aligned_free(output);
    ${model_name}_cleanup();
    
    ESP_LOGI(TAG, "Application finished");
}
