/*
 * Generated inference code for RISC-V target
 * Model: $model_name
 * Target: $target
 * Generated by cmx_tools
 */

$includes
#include <cmatrix.hpp>
#include <riscv_vector.h>

$defines

// Memory alignment for RISC-V
#define ALIGN_RISCV __attribute__((aligned(ALIGNMENT)))

// RISC-V Vector Extension macros
#ifdef __riscv_vector
#define RISCV_VLEN_BYTES ((__riscv_v_fixed_vlen) / 8)
#else
#define RISCV_VLEN_BYTES 32  // Default vector length
#endif

/*
 * Static tensor declarations
 * Optimized for RISC-V memory hierarchy
 */
$tensor_declarations

// Model weights and biases
static const float model_weights[] ALIGN_RISCV = {
    // Weights will be populated during code generation
    0.0f
};

static const float model_biases[] ALIGN_RISCV = {
    // Biases will be populated during code generation
    0.0f
};

// Working memory buffers
static float input_buffer[1024] ALIGN_RISCV;
static float output_buffer[1024] ALIGN_RISCV;
static float temp_buffer[2048] ALIGN_RISCV;

/*
 * RISC-V specific utility functions
 */
static inline uint64_t riscv_get_cycles(void) {
    uint64_t cycles;
    asm volatile ("rdcycle %0" : "=r" (cycles));
    return cycles;
}

static inline void riscv_fence(void) {
    asm volatile ("fence");
}

/*
 * Layer implementation functions with RISC-V optimizations
 */
$layer_functions

/*
 * Optimized convolution using RISC-V vector extensions
 */
void riscv_conv2d_optimized(const float* input, float* output, 
                           const float* weights, const float* bias,
                           int in_channels, int out_channels, int kernel_size) {
#ifdef __riscv_vector
    size_t vl = vsetvlmax_e32m1();
    
    for (int oc = 0; oc < out_channels; oc++) {
        vfloat32m1_t acc = vfmv_v_f_f32m1(bias[oc], vl);
        
        for (int ic = 0; ic < in_channels; ic++) {
            for (int k = 0; k < kernel_size * kernel_size; k++) {
                vfloat32m1_t inp = vle32_v_f32m1(&input[ic * kernel_size + k], vl);
                vfloat32m1_t wgt = vfmv_v_f_f32m1(weights[oc * in_channels * kernel_size * kernel_size + ic * kernel_size * kernel_size + k], vl);
                acc = vfmacc_vv_f32m1(acc, inp, wgt, vl);
            }
        }
        
        vse32_v_f32m1(&output[oc], acc, vl);
    }
#else
    // Fallback to scalar implementation
    cmx_conv2d(input, output, weights, bias, in_channels, out_channels, kernel_size);
#endif
}

/*
 * Model initialization
 */
int ${model_name}_init(void) {
    // Initialize cmx_core library
    if (cmx_init() != CMX_SUCCESS) {
        return -1;
    }
    
    // Clear buffers
    memset(input_buffer, 0, sizeof(input_buffer));
    memset(output_buffer, 0, sizeof(output_buffer));
    memset(temp_buffer, 0, sizeof(temp_buffer));
    
    // Memory fence to ensure initialization is complete
    riscv_fence();
    
    return 0;
}

/*
 * Model cleanup
 */
void ${model_name}_cleanup(void) {
    cmx_shutdown();
}

/*
 * Main inference function
 */
int ${model_name}_inference(const float* input, float* output) {
    // Validate inputs
    if (input == NULL || output == NULL) {
        return -1;
    }
    
    // Copy input to working buffer
    memcpy(input_buffer, input, ${model_name}_get_input_size() * sizeof(float));
    
    // Memory fence before computation
    riscv_fence();
    
    // Execute inference pipeline
$inference_loop
    
    // Memory fence after computation
    riscv_fence();
    
    // Copy result to output buffer
    memcpy(output, output_buffer, ${model_name}_get_output_size() * sizeof(float));
    
    return 0;
}

/*
 * Model metadata functions
 */
const char* ${model_name}_get_version(void) {
    return "1.0.0-riscv";
}

int ${model_name}_get_input_size(void) {
    return 224 * 224 * 3; // Will be replaced with actual size
}

int ${model_name}_get_output_size(void) {
    return 1000; // Will be replaced with actual size
}

/*
 * Performance monitoring
 */
void ${model_name}_print_perf_info(void) {
    printf("RISC-V Performance Information:\\n");
    
#ifdef __riscv_vector
    printf("Vector extension: Enabled\\n");
    printf("Vector length: %d bytes\\n", RISCV_VLEN_BYTES);
#else
    printf("Vector extension: Disabled\\n");
#endif

#ifdef __riscv_flen
    printf("Floating-point extension: %d-bit\\n", __riscv_flen);
#else
    printf("Floating-point extension: None\\n");
#endif
}

/*
 * Main function for standalone execution
 */
int main(void) {
    // Print system information
    printf("RISC-V Neural Network Inference\\n");
    ${model_name}_print_perf_info();
    
    // Initialize model
    if (${model_name}_init() != 0) {
        printf("Failed to initialize model\\n");
        return -1;
    }
    
    // Allocate input/output on stack
    float input[${model_name}_get_input_size()];
    float output[${model_name}_get_output_size()];
    
    // Initialize with dummy data for testing
    for (int i = 0; i < ${model_name}_get_input_size(); i++) {
        input[i] = 0.1f * (i % 10);
    }
    
    // Run inference with timing
    printf("Running inference...\\n");
    uint64_t start_cycles = riscv_get_cycles();
    
    int result = ${model_name}_inference(input, output);
    
    uint64_t end_cycles = riscv_get_cycles();
    uint64_t elapsed_cycles = end_cycles - start_cycles;
    
    if (result == 0) {
        printf("Inference completed successfully\\n");
        printf("Execution cycles: %lu\\n", elapsed_cycles);
        
        // Print first few outputs
        printf("Output (first 10 values): ");
        for (int i = 0; i < 10 && i < ${model_name}_get_output_size(); i++) {
            printf("%.3f ", output[i]);
        }
        printf("\\n");
    } else {
        printf("Inference failed with error code: %d\\n", result);
    }
    
    // Cleanup
    ${model_name}_cleanup();
    
    return result;
}
